package main

import (
	"fmt"
	"strings"
)

type rotor struct {
	wiring string
	offset int
}

func (r *rotor) forward(c byte) byte {
	i := int(c-'A'+byte(r.offset)) % 26
	return r.wiring[i]
}

func (r *rotor) backward(c byte) byte {
	i := strings.IndexByte(r.wiring, c)
	i = (i - r.offset + 26) % 26
	return byte(i + 'A')
}

type reflector struct {
	wiring string
}

func (r *reflector) reflect(c byte) byte {
	i := strings.IndexByte(r.wiring, c)
	return r.wiring[(i+13)%26]
}

type plugboard struct {
	pairs map[byte]byte
}

func (p *plugboard) plug(c byte) byte {
	if v, ok := p.pairs[c]; ok {
		return v
	}
	return c
}

type enigma struct {
	rotors    []*rotor
	reflector *reflector
	plugboard *plugboard
}

func (e *enigma) forward(c byte) byte {
	for i := len(e.rotors) - 1; i >= 0; i-- {
		c = e.rotors[i].forward(c)
	}
	c = e.reflector.reflect(c)
	for i := 0; i < len(e.rotors); i++ {
		c = e.rotors[i].backward(c)
	}
	c = e.plugboard.plug(c)
	return c
}

func (e *enigma) encrypt(s string) string {
	out := make([]byte, len(s))
	for i := 0; i < len(s); i++ {
		out[i] = e.forward(s[i])
	}
	return string(out)
}

func main() {
	r1 := &rotor{wiring: "EKMFLGDQVZNTOWYHXUSPAIBRCJ", offset: 0}
	r2 := &rotor{wiring: "AJDKSIRUXBLHWTMCQGZNPYFVOE", offset: 0}
	r3 := &rotor{wiring: "BDFHJLCPRTXVZNYEIWGAKMUSQO", offset: 0}
	ref := &reflector{wiring: "YRUHQSLDPXNGOKMIEBFZCWVJAT"}
	pb := &plugboard{pairs: map[byte]byte{'A': 'B', 'C': 'D', 'E': 'F'}}
	e := &enigma{rotors: []*rotor{r1, r2, r3}, reflector: ref, plugboard: pb}
	plaintext := "HELLO WORLD"
	ciphertext := e.encrypt(plaintext)
	fmt.Println("Plaintext:", plaintext)
	fmt.Println("Ciphertext:", ciphertext)
}
